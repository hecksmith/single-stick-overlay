<!DOCTYPE html>
<html>
  <head>
    <title>Single-Stick Overlay</title>
    <meta charset="UTF-8" />
    <!--
      NOTE: Set current stick and deadzone in the URL, e.g.
      https://<the-url>?stick=left&deadzone=0.05

      (For both sticks, set `stick=both`)
      https://<the-url>?stick=both...
    -->
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      html,
      body {
        position: relative;
        background: transparent;
      }

      body {
        padding: 15px;
      }

      td {
        vertical-align: middle;
      }

      .info {
        position: absolute;
        z-index: 1;
        left: 350px; /* TODO: Sync with stick size and number of sticks */
        bottom: 35px; /* TODO: Sync with bottom margin of sticks/bottom-padding of body */
        font-weight: 500;
        font-size: 18px; /* prev 1.5em (~20px) */
        font-family: monospace;
      }

      .status,
      .stick {
        padding: 4px 6px 6px 8px; /* top has least space to balance the descender on y */
        color: #fff;
        background-color: #111;
      }

      .stick + .stick {
        margin-top: 4px; /* prev 10px */
      }

      .vals-label {
        font-size: 16px;
      }
      .vals-label:after {
        content: ":";
        font-size: 20px;
      }

      .vals {
        width: 60px; /* prev 5rem */
        text-align: right;
      }

      .vals.zero {
        color: #a5a5a5;
      }

      body.dual-sticks .stick.left {
        border-left: 4px solid #55aaff;
      }
      body.dual-sticks .stick.right {
        border-left: 4px solid red;
      }
    </style>
  </head>

  <body>
    <div class="info">
      <div id="status" class="status"></div>
      <div id="stats"></div>
    </div>

    <!-- TODO: Sync with margin for info etc -->
    <canvas id="canvas" width="350" height="225"></canvas>

    <script type="module">
      import "./joypad.min.js";
      import throttle from "./lodash.throttle@4.1.1.min.js";

      const DEBUG = localStorage.debug && localStorage.debug.includes("*");

      // Default gamepad config
      const DEFAULT_STICK = "right";
      const DEFAULT_DEADZONE = "0.01";
      const DEFAULT_DEADZONES = "0.01,0.01";

      // Visual config
      const DECIMAL_PLACES = 2;
      const RADIUS = 100;
      const MARGIN = 10; // margin between two sticks & above sticks

      // Options
      const DEFLICKER = true;

      // Get any custom configuration from URL query params
      const PARAMS = new URLSearchParams(window.location.search);
      const STICK = PARAMS.get("stick") || DEFAULT_STICK;
      const DEADZONES = getDeadzoneParam();

      // prettier-ignore
      const sticksToDisplay = (STICK === "left" || STICK === "right")
        ? [STICK]
        : ["left", "right"];

      // Elements
      const $id = document.getElementById.bind(document);
      const ctx = $id("canvas").getContext("2d");
      const $stats = $id("stats");
      const $status = $id("status");

      // Set a class on the `body` for styling
      if (sticksToDisplay.length > 1) {
        document.body.classList.add("dual-sticks");
      }

      // Throttle draw function to 60fps
      const drawThrottled = throttle(draw, 16, { trailing: true });

      // Global state, shared by drawing functions
      const STATE = {
        isConnected: false,
        left: { x: 0, y: 0 },
        right: { x: 0, y: 0 },
      };

      // Wire up âœ¨
      const DIR_TO_AXIS = { left: "x", right: "x", top: "y", bottom: "y" };

      // IMPORTANT: Must be set to 0, else no "axis_move" events are
      //            sent when the stick is reset to center (0 value).
      joypad.set({ axisMovementThreshold: 0 });

      joypad.on("axis_move", ({ detail }) => {
        const whichMoved = detail.stickMoved.split("_")[0]; // `stickMoved` is either left_stick or right_stick
        const axis = DIR_TO_AXIS[detail.directionOfMovement];

        if (sticksToDisplay.includes(whichMoved)) {
          const valueWithDeadzone = applyDeadZoneAndFormatValue(detail.axisMovementValue, whichMoved);
          const shouldDraw = shouldDrawNewValue(STATE[whichMoved][axis], valueWithDeadzone);

          if (DEBUG) {
            const valueWithDP = parseFloat(detail.axisMovementValue.toFixed(DECIMAL_PLACES));
            console.log(axis, `New? [${shouldDraw}]`, valueWithDP, "with DZ:", valueWithDeadzone, "raw:", detail.axisMovementValue); // prettier-ignore
          }

          if (shouldDraw) {
            STATE[whichMoved][axis] = valueWithDeadzone;
            drawThrottled();
          }
        }
      });

      joypad.on("connect", handleConnect);
      joypad.on("disconnect", handleDisconnect);

      handleDisconnect();

      // Rendering

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        sticksToDisplay.forEach((s) => drawStick(s));
        drawStats();
      }

      function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        $stats.innerHTML = "";
      }

      function drawStick(stick) {
        const yOffset = MARGIN;
        const xOffset = sticksToDisplay.length > 1 && stick === "right" ? RADIUS + MARGIN * 2 : MARGIN;
        const radius = sticksToDisplay.length > 1 && stick === "left" ? RADIUS / 2 : RADIUS;

        // Background circle stroke
        circle(radius + xOffset, radius + yOffset, radius + 1, "#555");

        // Background circle
        circle(radius + xOffset, radius + yOffset, radius, "#111"); // prev #222

        // Dot for current stick value
        const x = Number(STATE[stick].x) * radius + radius + xOffset;
        const y = Number(STATE[stick].y) * radius + radius + yOffset;

        const dotColor = stick === "right" ? "red" : "#55aaff";
        circle(x, y, RADIUS / 10, dotColor);

        // Center point
        circle(radius + xOffset, radius + yOffset, 1, "white");
      }

      function drawStats() {
        // Ensure the disconnected message is cleared on any stats update
        if (!STATE.isConnected) handleConnect();

        const html = sticksToDisplay
          .map((stick) => {
            const { x: xVal, y: yVal } = STATE[stick];

            // NOTE: toFixed() is used again to handle `0` -> `0.00`
            const x = xVal.toFixed(DECIMAL_PLACES);
            const y = yVal.toFixed(DECIMAL_PLACES);

            return `
            <div class="stick ${stick}">
              <table>
                <tr>
                  <td class="vals-label">X</td>
                  <td class="vals ${x === "0.00" ? "zero" : ""}">${x}</td>
                </tr>
                <tr>
                  <td class="vals-label">Y</td>
                  <td class="vals ${y === "0.00" ? "zero" : ""}">${y}</td>
                </tr>
              </table>
            </div>
            `;
          })
          .join("");

        $stats.innerHTML = html;
      }

      function handleDisconnect() {
        STATE.isConnected = false;

        setTimeout(() => {
          clear();
          $status.innerText = "Disconnected";
          $status.style.display = "block";
        }, 15);
      }

      function handleConnect() {
        STATE.isConnected = true;
        $status.style.display = "none";
      }

      // Helpers

      function circle(x, y, radius, fillStyle) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = fillStyle;
        ctx.fill();
      }

      // Whether or not to draw the new value, including simplistic de-flickering logic
      function shouldDrawNewValue(newValue, oldValue) {
        if (DEFLICKER) {
          const diff = parseFloat(Math.abs(newValue - oldValue).toFixed(2));
          return diff > 0.01 || newValue === 0;
        } else {
          return newValue !== oldValue;
        }
      }

      function isOutsideDeadzone(value, stickName) {
        const deadzone = stickName === "left" ? DEADZONES[0] : DEADZONES[1];

        return (value > 0 && value > deadzone) || (value < 0 && value < deadzone * -1);
      }

      function applyDeadZoneAndFormatValue(value, stickName) {
        return isOutsideDeadzone(value, stickName) ? parseFloat(value.toFixed(DECIMAL_PLACES)) : 0;
      }

      function getDeadzoneParam() {
        // Legacy param - single "deadzone" value applied to both sticks
        if (PARAMS.get("deadzone")) {
          const value = Number(PARAMS.get("deadzone"));
          return [value, value];
        }

        // Default param style (comma-separated) e.g. deadzones=0.01,0.05
        let deadzonesStr;

        if (PARAMS.get("deadzones") && PARAMS.get("deadzones").split(",").length !== 2) {
          console.error(
            "Incorrect formatting for 'deadzones' URL parameter. Should be `<left>,<right>` e.g. `deadzones=0.01,0.05`"
          );
          deadzonesStr = DEFAULT_DEADZONES;
        } else {
          deadzonesStr = PARAMS.get("deadzones") || DEFAULT_DEADZONES;
        }

        return deadzonesStr.split(",").map(Number);
      }
    </script>
  </body>
</html>
